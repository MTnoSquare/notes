## 介绍

该RPC框架基于Netty和Socket两种IO方式，实现了四种序列化的方式进行数据传输，通过自定义协议实现远程方法调用的数据包装，以代理模式屏蔽了方法调用的细节，实现本地的无感调用。从整体框架出发分为客户端，服务端和注册中心三个部分，注册中心保存了服务端的地址和服务名，服务端启动的时候通过服务方法的注解进行在注册中心的注册和本地服务表的注册。同时通过客户端和服务端间的心跳机制感知服务端的存活。


## 架构图


## RPC调用流程

### 本地实现

#### 客户端

1. 元数据配置(服务名,版本号,组)和客户端信息配置(传输实现,负载均衡等配置)
2. 利用元数据进行服务发现
3. 客户端初始化,连接服务
4. 工厂类通过接口地址创建实例
5. 调用实例方法
6. 集群容错和负载均衡策略调用服务

#### 服务端

1. 元数据配置
2. SPI加载服务类实现,服务端初始化
3. 将服务注册到本地服务队列中
4. 注册到注册中心
5. 绑定监听

### Spring实现

#### 启动

1. 在yml文件中配置rpc基本信息,注册配置类
2. 注册`Bean`
    1. `CommandLineRunner`接口实现类启动服务提供者容器,
    2. `ApplicationContextAware, DisposableBean`接口实现类通过静态变量保存Spring ApplicationContext, 可在任何代码任何地方任何时候取出ApplicaitonContext.
    3. `BeanPostProcessor`后置处理器接口实现类启动消费者容器

#### 消费者

在服务接口上启用`@Refercene`注解,信息包含了服务名,版本号等.`BeanPostProcessor`后置处理器接口实现类会对含有该注解的类进行扫描,并通过代理工厂获取对应实例,将实例注入bean

#### 客户端
<!-- 7. 客户端通过代理类获取被代理的类的信息，调用类的方法。
1. 在代理类中，代理类封装`RPCrequest`，通过Netty客户端从nacos中获取代理的所有服务地址，根据负载均衡策略选取一个，创建channel进行连接，向服务端发送请求并监听
2.  服务端接收到请求后反序列化，根据信息在本地服务表获取服务实体进行调用，最后返回。 -->
## 网络层


### 协议设计
```
 * ----------------------------------------------------------------------------------
 * |                        protocol                                                |
 * ----------------------------------------------------------------------------------
 * |  2byte | 1byte | 1byte     | 1byte     |   8byte   |   4byte    |              |
 * ----------------------------------------------------------------------------------
 * |        |       |           |           |           |            |              |
 * |  magic |  mode |serialize  | status    | requestId |  length    |   body       |
 * | 0xbabe |       |           |           |           |            |              |
 * ----------------------------------------------------------------------------------
```

**java代码DTO设计**
```java
    /**
     * 魔法数 2位
     */
    private short magic = (short) 0xbabe;

    /**
     * 请求模式 1位
     * 0x01 - req - oneWay 非异步请求,不需要知道处理结果
     * 0x02 - req - twoWay 和上面相反
     * 0x21 - resp
     * 0x22 - Heartbeat
     */
    private byte type;

    /**
     * 序列化方式 1位
     * 0x01 - JSON
     */
    private byte codec = CodecType.CODEC_TYPE_JSON.getType();

    /**
     * 请求id， 8位
     */
    private long requestId = atomicLong.getAndIncrement();

    /**
     * 请求长度，4位
     */
    private int length;

    /**
     * 内容体
     */
    private Object body;
```




## 传输层

### Netty
//TODO:

### 心跳机制

双向的心跳机制，服务端收到心跳请求包后不回复，而是由客户端注册监听器监听

Netty通过IdleStateHandler实现最常见的心跳机制不是一种双向心跳的PING-PONG模式，而是客户端发送心跳数据包，服务端接收心跳但不回复，因为如果服务端同时有上千个连接，心跳的回复需要消耗大量网络资源；如果服务端一段时间内没有收到客户端的心跳数据包则认为客户端已经下线，将通道关闭避免资源的浪费；在这种心跳模式下服务端可以感知客户端的存活情况，无论是宕机的正常下线还是网络问题的非正常下线，服务端都能感知到，而客户端不能感知到服务端的非正常下线；

## 注册中心

### Subscribe

客户端根据元数据进行服务发现并连接

### Registery

服务端根据元数据注册服务

## 服务的注销

单例模式创建钩子

钩子里调用注销服务的方法
```
Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            NacosUtil.clearRegistry();
            //关闭所有线程池
            ThreadPoolFactory.shutDownAll();
        }));
```

该方法用来在jvm中增加一个关闭的钩子。**当程序正常退出,系统调用 System.exit方法或虚拟机被关闭时才会执行**添加的shutdownHook线程。其中shutdownHook是一个已初始化但并不有启动的线 程，当jvm关闭的时候，会执行系统中已经设置的所有通过方法addShutdownHook添加的钩子，当系统执行完这些钩子后，jvm才会关闭。所以 可通过这些钩子在jvm关闭的时候进行内存清理、资源回收等工作。




## 集群策略

### 1.广播调用

>所有提供逐个调用，任意一台报错则报错。通常用于**更新提供方本地状态** 速度慢，任意一台报错则报错 。

>广播调用不进行负载均衡策略

### 2.失败恢复

>失败自动恢复，后台记录失败请求，定时重发，通常用于**消息通知**操作。

通过Java定时线程池` Executors.newScheduledThreadPool`实现定时重发,通过哈希表维护失败请求.


### 3.快速失败

>只发起一次调用，失败立即报错,通常用于**非幂等性的写操作**。 如果有机器正在重启，可能会出现调用失败

### 4.失败自动切换

>失败转移，当出现失败，重试其它服务器，**通常用于读操作**，但重试会带来更长延迟。

默认重试次数2

### 5.失败安全

>快速失败，只发起一次调用，失败立即报错，**通常用于非幂等性的写操作**。

与快速失败的区别是失败会报错
### 
## 设计模式

**工厂模式**:创建线程池，生成单例类

**策略模式**:实现相同的序列化接口,方法内部不同的实现,根据传入的参数(序列码)选择对应的序列化类.

**单例模式**