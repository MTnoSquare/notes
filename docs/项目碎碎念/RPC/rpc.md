## 介绍

该RPC框架基于Netty和Socket两种IO方式，实现了四种序列化的方式进行数据传输，通过自定义协议实现远程方法调用的数据包装，以代理模式屏蔽了方法调用的细节，实现本地的无感调用。从整体框架出发分为客户端，服务端和注册中心三个部分，注册中心保存了服务端的地址和服务名，服务端启动的时候通过服务方法的注解进行在注册中心的注册和本地服务表的注册。同时通过客户端和服务端间的心跳机制感知服务端的存活。

## 传输协议
```
+---------------+---------------+-----------------+-------------+
|  Magic Number |  Package Type | Serializer Type | Data Length |
|    4 bytes    |    4 bytes    |     4 bytes     |   4 bytes   |
+---------------+---------------+-----------------+-------------+
|                          Data Bytes                           |
|                   Length: ${Data Length}                      |
+---------------------------------------------------------------+
```

## RPC调用流程

1. 客户端通过代理类获取被代理的类的信息，调用类的方法。
2. 在代理类中，代理类封装`RPCrequest`，通过Netty客户端从nacos中获取代理的所有服务地址，根据负载均衡策略选取一个，创建channel进行连接，向服务端发送请求并监听
3. 服务端接收到请求后反序列化，根据信息在本地服务表获取服务实体进行调用，最后返回。


## 如何通信
Socket和Netty
### Socket
基于BIO实现，字节流读取和输入。

服务端创建线程池对accpet队列上的连接进行处理。

客户端不会主动关闭socket连接。(频繁创建导致资源消耗)
### Netty
基于NIO实现

## 服务器服务的注册与发现
`ServiceProvider`负责保存和提供服务实例对象

`ServiceRegistry`负责注册服务到Nacos中去

对于服务实现类，使用`@Service`注解

在抽象类实现扫描注解方法`scanServices()`，核心是利用反射，利用Service注解判断该类是否为服务类，将其创建实例存放在`ServiceProvider`实现类中，用`ConcurrentHashMap`进行存储，**同时注册到Nacos中**。

由于一个服务可能实现了多个接口，所以不同的接口该服务都要进行注册

## 服务的注销

单例模式创建钩子

钩子里调用注销服务的方法
```
Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            NacosUtil.clearRegistry();
            //关闭所有线程池
            ThreadPoolFactory.shutDownAll();
        }));
```

该方法用来在jvm中增加一个关闭的钩子。**当程序正常退出,系统调用 System.exit方法或虚拟机被关闭时才会执行**添加的shutdownHook线程。其中shutdownHook是一个已初始化但并不有启动的线 程，当jvm关闭的时候，会执行系统中已经设置的所有通过方法addShutdownHook添加的钩子，当系统执行完这些钩子后，jvm才会关闭。所以 可通过这些钩子在jvm关闭的时候进行内存清理、资源回收等工作。


## 心跳机制

双向的心跳机制，服务端收到心跳请求包后不回复，而是由客户端注册监听器监听

Netty通过IdleStateHandler实现最常见的心跳机制不是一种双向心跳的PING-PONG模式，而是客户端发送心跳数据包，服务端接收心跳但不回复，因为如果服务端同时有上千个连接，心跳的回复需要消耗大量网络资源；如果服务端一段时间内没有收到客户端的心跳数据包则认为客户端已经下线，将通道关闭避免资源的浪费；在这种心跳模式下服务端可以感知客户端的存活情况，无论是宕机的正常下线还是网络问题的非正常下线，服务端都能感知到，而客户端不能感知到服务端的非正常下线；

## 序列化

## 设计模式

**工厂模式**:创建线程池，生成单例类

**策略模式**:实现相同的序列化接口,方法内部不同的实现,根据传入的参数(序列码)选择对应的序列化类.

**单例模式**