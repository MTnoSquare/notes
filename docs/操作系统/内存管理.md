![](https://community-header-1306990603.cos.ap-guangzhou.myqcloud.com/20220113235657.png)
图源:王道考研

**内存管理分为连续分配和非连续分配方式**
## 连续分配方式
1. **单一连续分配**
   
   内存分为系统区和用户区，**内存中只能有一道用户程序**

2. **固定分区分配**
   
   操作系统需要建立一个分区说明表实现各个分区的分配与回收，**即预先划分内存分区**。当程序太大时可能所有分区都无法满足，只能采用覆盖技术解决，且会产生内部碎片
3. **动态分区分配**
   
   又称可变分区分配，不会预先划分内存分区，而是在进程装入内存时，根据进程大小动态地建立分区。会产生外部碎片。
>外部碎片：指内存中某些空闲分区太小难以利用

>内部碎片:分配给某进程的内存区域中，有部分没有用上

### 动态分区分配算法

|     算法     |            算法思想            |        分区排列顺序        |            优点            |                               缺点                               |
| :----------: | :----------------------------: | :------------------------: | :------------------------: | :--------------------------------------------------------------: |
| 首次适应算法 |      从头到尾找适合的分区      | 空闲分区以地址递增次序排列 |      性能最好，开销小      |                                                                  |
| 最佳适应算法 |       优先使用更小的分区       | 空闲分区以容量递增次序排列 | 保留大分区，满足大进程需求 | 开销大，需要对空闲分区队列重新排序；产生很多太小的难以利用的碎片 |
| 最坏适应算法 |       优先使用更大的分区       | 空闲分区以容量递增次序排列 |     减少难以利用的碎片     |           大分区容易被用完，不利用大进程；开销大(同上)           |
| 临近适应算法 | 每次从上次查找结束位置开始查找 | 空闲分区以地址递增次序排列 |   开销小(同首次适应算法)   |                    会使高地址的大分区也被用完                    |

## 非连续分配方式
允许程序分散地装入到不相邻的内存分区中。根据分区的大小是否固定分为**分页存储管理方式**和**分段存储管理方式**。

分页存储管理方式中，又根据运行作业时是否要把作业所有页面都装入内存才能运行分为**基本分页存储管理方式**和**请求分页存储管理方式。**

### 1. 基本分页存储管理方式

   进程中的块称为**页（页面）**，内存中的块称为**页框（页帧）**。外存也以同样的单位进行划分，直接称为块。

**页表**：由页表项组成(页号+块号)，作用是**实现从页号到物理块号的地址映射**(进程每个页面对应一个页表项)

块号+偏移量共同组成**物理地址**。**页号不占用存储空间。**

>还可引入两级(多级)页表解决页表过大和页表常驻内存的问题

**基本地址变换机构**

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。

通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址F 和页表长度M。 进程未执行时，页表的始址 和 页表长度 放在进程控制块（PCB）中，当进程被调度时，操作系 统内核会把它们放到页表寄存器中。

设页面大小为L,逻辑地址A到物理地址E的变换过程如下：

![](https://community-header-1306990603.cos.ap-guangzhou.myqcloud.com/20220114105121.png)


 物理地址**E=b $\times$ L+W**


### 2. 基本分段存储管理方式
   
**概念：**

按照程序自身的逻辑关系划分为若干个段，各段之间可以不相邻。

| 31   ......    16 | 15   ......   0 |
| :---------------: | :-------------: |
|       段号        |    段内地址     |

>段号位数决定每个进程最多可以分几个段
>段内地址位数决定每个段的最大长度

分段分页管理的区别

|          |                           分页                           |                 分段                 |
| :------: | :------------------------------------------------------: | :----------------------------------: |
|   单位   |                           物理                           |                 逻辑                 |
|   目的   |                       实现离散分配                       |             满足用户需求             |
|  对用户  |                          不可见                          |                 可见                 |
|   大小   |                      固定，系统决定                      |          不固定，取决于程序          |
| 地址空间 |                           一维                           |         二维(段名+段内地址)          |
|   优点   | 内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片 | 很方便按照逻辑模块实现信息共享和保护 |
|   缺点   |             不方便按照逻辑实现信息共享和保护             |             产生外部碎片             |

### 3. 段页式管理方式
   

   **概念**：

   将进程按逻辑模块分段，再将各段分页

| 31   ......    16 | 15   ......   12 | 11   ......   0 |
| :---------------: | :--------------: | :-------------: |
|       段号        |       页号       |   页内偏移量    |

## 虚拟内存

**概念**:

基于**局部性原理**，在程序装入时，将程序中很快会用到的部分装入内存，暂时用不到的留在外存。
在程序执行过程中，所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序
若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。

>局部性原理    
>时间局部性（程序中存在大量循环操作）:某条指令执行后不久以后可能再次执行  
>空间局部性:一旦程序访问某个存储单元，不久以后附近的存储单元也将被访问。

**实现方式**

1. 请求分页存储管理
2. 请求分段存储管理
3. 请求段页式存储管理

### 页面置换算法

1. 最佳置换算法(无法实现)
   
   OPT选择的被淘汰页面是以后永不使用的或者最长时间内不再被访问的页面。保证最低缺页率。

2. 先进先出页面置换算法
   
   每次淘汰的页面是最早进入内存的页面

>Belady异常——当为进程分配的物理块数增大时。缺页次数不减反增。

3. 最近最久未使用算法
   
   每次淘汰的页面是最近最久未使用的页面。

4. 时钟(CLOCK)置换算法(NRU)
   
   实现方法：为每个页面设置一个访问位，将内存中的页面链接成一个循环队列。被访问时，访问位设为1.
当需要淘汰时，检查访问位，0则换出，1则置0，继续检查。
若第一轮都为1，则进行第二轮。
简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描。

5. 改进型时钟置换算法
   
   简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过， 就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。
   在其他条件相同时，应优先淘汰没有修改过的页面，避免I/O操作。


||算法规则|优点|缺点|
|:-:|:-:|:-:|:-:|
|OPT|优先淘汰最长时间内不会被访问页面|缺页率最小，性能最好|无法实现|
|FIFO|优先淘汰最先进入内存页面|实现简单|性能差，会出现Belady异常|
|LRU|优先淘汰最近最久没访问的页面|性能好|需要硬件支持，开销大|
|CLOCK|循环扫描各页面，第一轮淘汰访问位=0的，没淘汰的访问位设置为1；若第一轮没选中，第二轮继续|实现简单，开销小|未考虑页面是否被修改过|
|改进型CLOCK|增加修改位|开销较小||