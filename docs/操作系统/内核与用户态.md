## 虚拟地址空间

操作系统将每个进程的虚拟地址空间划分成两个部分：内核空间和用户空间。内核空间存放的是内核代码和数据，用户空间存放的是用户程序的代码和数据。在 32 位操作系统中，一般将最高的 1G 字节作为内核空间，而将较低的 3G 字节作为用户空间。

进程运行在内核空间时，处于内核态，此时可以执行任何特权指令。每个进程的内核空间都是相同的，用户代码无法访问内核空间。

![](https://community-header-1306990603.cos.ap-guangzhou.myqcloud.com/20220422114753.png)

* **内核虚拟内存**:所有进程共享内核的代码和全局数据结构，独享与进程相关的数据结构，Linux 会将内核虚拟内存的共享区域映射到被所有进程共享的物理页面上
* 用户栈：从高地址向低地址增长
* 共享库：动态链接阶段
* 运行时堆：从低地址向高地址增长
* 程序代码和数据：从可执行文件中加载（代码段、数据段、BSS 段）
## 用户态和内核态

根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别：

* 用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。
* 内核态(kernel mode):可以简单的理解内核态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。

凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。


这些系统调用按功能大致可分为如下几类：

* 设备管理。完成设备的请求或释放，以及设备启动等功能。
* 文件管理。完成文件的读、写、创建及删除等功能。
* 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
* 进程通信。完成进程之间的消息传递或信号传递等功能。
* 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。


## 陷入内核态的方式

1. **系统调用(trap)**

用户态进程主动要求切换到内核态的一种方式,用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如 read 操作.而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。


2. **中断(interrupt)**

中断由处理器外部的硬件产生，不是执行某条指令的结果，也无法预测发生时机。由于中断独立于当前执行的程序，因此中断是异步事件。

中断包括 I/O 设备发出的 I/O 中断、各种定时器引起的时钟中断、调试程序中设置的断点等引起的调试中断等。

3. **异常(exception)**

异常是一种错误情况，是执行当前指令的结果，可能被错误处理程序修正，也可能直接终止应用程序。异常是同步的。

当发生异常时，操作系统会将控制转移给相应的异常处理程序。如果处理程序能够修正这个错误情况，就将**返回到引起异常的指令**重新执行。否则，终止该应用程序。

常见的异常
1. 除法错误:当应用程序试图除以零，或者一个除法指令结果溢出的时候，就会发生除法错误。Linux 会直接终止程序。
2. 一般保护故障：当程序访问一个未定义的虚拟内存区域(如访问空指针)，或者试图写一个只读的文本段，Linux 会直接终止程序。
3. 缺页异常:当应用程序访问未加载的页面时，会引起缺页异常。缺页处理程序会加载适当的页面，然后重新执行引起异常的指令


这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。


## 堆和栈

### 栈

用户栈其实就是函数调用栈，作用主要是：

* 保存函数的局部变量
* 保存某些寄存器的值
* 向被调用函数传递参数
* 返回函数的返回值
* 保存函数的返回地址


每个函数在执行过程中都需要使用一块栈内存用来保存上述这些值，这块栈内存为该函数的栈帧（stack frame）。栈的增长和收缩由编译器插入的代码自动完成，随着函数的调用而分配，随函数的返回而自动释放。程序员无需关心，这一点与堆不同。

### 堆

栈内存的分配需要实现确定其大小，而堆内存允许程序在运行时动态申请某个大小的内存空间。申请的内存在函数退出后依然保留，需要手动释放。C 语言中的 malloc / free 就是从堆中分配 / 释放内存，操作系统通过一个记录空闲内存地址的链表来管理堆内存。

如果反复向操作系统申请堆内存而不释放，会导致内存泄漏。在 C / C++ 中，必须由程序员手动释放堆内存。而 Java / Golang 中有垃圾回收器，会定期主动回收内存。但是即使有垃圾回收器，也有内存泄漏的风险，比如长期持有某个大对象的引用。

### 堆和栈区别

* **增长方向**：栈向低地址方向增长，堆向高地址方向增长
* **申请回收**：栈自动分配和回收，堆需要手动申请和释放
* **生命周期**：栈的数据仅存在于函数运行过程中，堆的数据只要不释放就一直存在
* **连续分配**：栈是连续分配的，堆是不连续的，容易产生内存碎片
* **空间大小**：栈的大小是有限的（如默认 8M，Linux 上通过 ulimit -s 查看），而堆的空间较大，受限于系统中有效的虚拟内存
