## 死锁产生的四个必要条件

* 互斥条件
* 占有并等待:线程占有已经分配给它们的资源（如锁）并且等待其他的资源（也就是说不会主动释放）
* 不可抢占(只会主动释放)
* 环路等待:每个进程都在等待下一个进程占有的资源

## 如何预防

破坏上面四个条件任意一个，但是很难

1. 破坏互斥条件:允许资源被多个进程访问，实用性有限
2. 破坏占有并等待条件:资源预先分配(当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行),但一般无法预知一个进程所需的全部资源
3. 破坏非抢占条件:允许进程强行抢占其他进程占有的资源，会降低系统性能
4. 破坏循环等待条件:对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出

## 如何检测

画出资源分配图，检测是否存在环路。检测环路前要将资源分配图化简，化简的原理是“一个目前占有运行所需的资源的进程，迟早能够执行完成释放资源”。因此，可以从“进程—资源分配图”中找到一个既不阻塞又非孤立的进程，删除所有与该进程相连的有向边，回收资源，使之成为孤立结点，然后将所回收的资源分配给其它进程。循环此过程，直到无法化简。若仍存在环路，则该系统目前处于死锁状态。
## 如何避免

允许系统中同时存在四个必要条件，但是每当进程提出资源申请时，系统要分析满足该资源请求后，系统是否会发生死锁，若不会发生则实施分配，否则拒绝分配。银行家算法实现了这个过程。

## 如何解除

破坏除了“互斥条件”之外的其他三个条件