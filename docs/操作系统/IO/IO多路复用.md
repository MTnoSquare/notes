# 概念
非阻塞IO可以解决多线程切换开销大的阻塞IO的问题，但是缺点是：**每次发起系统调用只能检查一个文件描述符是否就绪。当文件描述符很多时，系统调用成本很高。**  
而IO多路复用可以**通过一次系统调用，检查多个文件描述符状态**  

> I/O 多路复用相当于将「遍历所有文件描述符、通过非阻塞 I/O 查看其是否就绪」的过程从用户线程移到了内核中，由内核来负责轮询。
# select
时间复杂度O(n)，它仅仅知道了，有I/O事件发生了，却并不知道是哪几个流（可能有一个，多个，甚至全部），只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。
>int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);  

select 函数监视的文件描述符分3类，分别是`writefds、readfds`和`exceptfds`。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。
## 缺点
1. **性能开销大**  
   1.调用` select `时会陷入内核，这时需要将参数中的 `fd_set` 从用户空间拷贝到内核空间  
   2.内核需要遍历传递进来的所有 `fd_set` 的每一位，不管它们是否就绪
2. **同时能够监听的文件描述符数量太少**  
   受限于` sizeof(fd_set) `的大小，在编译内核时就确定了且无法更改。一般是 1024，不同的操作系统不相同   
# poll
`poll` 和 `select` 几乎没有区别。poll 在用户态通过数组方式传递文件描述符，在内核会转为链表方式存储，没有最大数量的限制  
# epoll
epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。时间复杂度`O(1)`

简而言之，epoll 有以下几个特点：

* 使用红黑树存储文件描述符集合
* 使用队列存储就绪的文件描述符
* 每个文件描述符只需在添加时传入一次；通过事件更改文件描述符状态
select、poll 模型都只使用一个函数，而 epoll 模型使用三个函数：`epoll_create、epoll_ctl` 和 `epoll_wait`。
## 优点  
`epoll` 是对 `select` 和 `poll` 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。

对于“文件描述符数量少”，`select` 使用整型数组存储文件描述符集合，而 `epoll` 使用红黑树存储，数量较大。

对于“性能开销大”，`epoll_ctl` 中为每个文件描述符指定了回调函数，并在就绪时将其加入到就绪列表，因此 `epoll` 不需要像 `select` 那样遍历检测每个文件描述符，只需要判断就绪列表是否为空即可。这样，在没有描述符就绪时，`epoll` 能更早地让出系统资源。
# 对比
* `select：`调用开销大（需要复制集合）；集合大小有限制；需要遍历整个集合找到就绪的描述符
* `poll：`poll 采用数组的方式存储文件描述符，没有最大存储数量的限制，其他方面和 select 没有区别
* `epoll：`调用开销小（不需要复制）；集合大小无限制；采用回调机制，不需要遍历整个集合
`select、poll `都是在用户态维护文件描述符集合，因此每次需要将完整集合传给内核；`epoll` 由操作系统在内核中维护文件描述符集合，因此只需要在创建的时候传入文件描述符。

此外 `select` 只支持水平触发，`epoll` 支持边缘触发。
# 水平触发、边缘触发
`select` 只支持水平触发，`epoll` 支持水平触发和边缘触发。

水平触发（LT，Level Trigger）：当文件描述符就绪时，会触发通知，如果用户程序没有一次性把数据读/写完，下次还会发出可读/可写信号进行通知。

边缘触发（ET，Edge Trigger）：仅当描述符从未就绪变为就绪时，通知一次，之后不会再通知。

区别：边缘触发效率更高，减少了事件被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。

>水平触发、边缘触发的名称来源：数字电路当中的电位水平，高低电平切换瞬间的触发动作叫边缘触发，而处于高电平的触发动作叫做水平触发。