## 进程和线程的概念
**进程**是一个资源分配的基本单位。进程拥有的资源包括：内存空间中的代码、数据等；I/O 资源；文件；处理机等。

**线程**是一个独立调度的基本单位，一个进程可以有多个线程。线程只拥有处理机，线程之间共享进程的资源，如内存、I/O 等。

|          |            进程            |                线程                 |
| :------: | :------------------------: | :---------------------------------: |
|   资源   |     资源分配的基本单位     |   没有，但可以访问所属进程的资源    |
| 切换开销 |             大             |                 小                  |
|  健壮性  | 健壮，多个进程不会互相干扰 | 不健壮,一个线程出错导致整个进程挂掉 |
|   通信   |            IPC             |              共享内存               |

### 同一进程中线程共享与独占的资源

**共享资源**：
1. 内存空间
   1. 代码
   2. 公共数据(全局变量，静态变量)
   3. 堆
2. 文件描述符
3. 信号处理器
4. 进程ID

**独占资源**：
1. 线程ID
2. 一组寄存器的值
3. 栈：每个线程中的函数调用过程是独立的，因此需要有独立的栈
4. 错误返回码：系统调用或库函数发生错误时，会设置全局变量 errno，各个线程的错误返回码应该是独立的
5. 信号屏蔽码：每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理；但每个线程都共享本进程的信号处理器


### PCB

进程控制块，主要包含以下内容
* 进程的描述信息，比如进程的名称，标识符，
* 处理机的状态信息，当程序中断是保留此时的信息，以便 CPU 返回时能从断点执行
* 进程调度信息，比如阻塞原因，状态，优先级等等
* 进程控制和资源占用，同步通信机制，链接指针（指向队列中下一个进程的 PCB 地址）

其作用如下：
* PCB是进程实体的一部分，是进程的唯一标识符，是操作系统中最重要的数据结构
* 由于它的存在，使得多道程序环境下，不能独立运行的程序成为一个能独立运行的基本单位，使得程序可以并发执行
### Linux中的进程与线程
Linux中不区分进程和线程，均使用`do_fork`系统函数创建，只是对一些系统资源，如虚拟内存，进程ID，文件描述符等资源共享程度不同。
>父子进程仅共享程序文本段
## 进程通信方式
|   方式   |    传输的信息量    |    使用场景    |                                 关键词                                 |
| :------: | :----------------: | :------------: | :--------------------------------------------------------------------: |
|   信号   |        少量        |      任何      |                     硬件来源、软件来源 / 信号队列                      |
|   管道   |        大量        |   亲缘进程间   | 单向流动 / 内核缓冲区 / 循环队列 / 没有格式的字节流 / 操作系统负责同步 |
| 命名管道 |        大量        |      任何      |     磁盘文件 / 访问权限 / 无数据块 / 内核缓冲区 / 操作系统负责同步     |
|  信号量  |         N          |      任何      |                     互斥同步 / 原子性 / P 减 V 增                      |
| 共享内存 |        大量        |    多个进程    |                内存映射 / 简单快速 / 操作系统不保证同步                |
| 消息队列 | 比信号多，但有限制 |      任何      |               有格式 / 按消息类型过滤 / 操作系统负责同步               |
|  套接字  |        大量        | 不同/相同主机的进程 |                 读缓存区 / 写缓冲区 / 操作系统负责同步                 |


### 1. 管道/匿名管道

* 半双工，数据单向流动，当双方通信时，需要建立两个管道
* 只能用于亲缘进程(父子或兄弟)
* 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。
  
 ![管道模型](https://upload-images.jianshu.io/upload_images/1281379-05378521a7b41af4.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

**局限**:

* 单向数据流，没有名字，缓冲区有限(管道存在于内存中)
* 传送的是无格式字节流，管道读出方和写入方必须事先约定好数据格式

### 2. FIFO(有名管道)
   
   去除了管道只能在父子进程中使用的限制。
   
   有名管道的文件形式存在于**文件系统中**，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循**先进先出(first in first out)**,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。有名管道的名字存在于文件系统中，内容存放在内存中。

### 3. 信号
   
* 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。
* 如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。
* 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。

    >Linux常用信号：
    >SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。
    >SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。
    >SIGQUIT：程序退出信号。程序运行过程中，按Ctrl+\\键将产生该信号。
    >SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。
    >SIGTERM：结束进程信号。shell下执行kill 进程pid发送该信号。
* 信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：

    * 硬件来源：用户按键输入Ctrl+C退出、硬件异常如无效的存储访问等。
    * 软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。

### 4. 消息队列
   
* 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。
* 只有内核重启(即操作系统重启)或显示地删除一个消息队列时，才会被真正删除
* 消息队列允许一个或多个进程向它写入与读取消息.
* 管道和消息队列的通信数据都是先进先出的原则。
* 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。
* 消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。

### 5. 共享内存
   * 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。
   * 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。
   * 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。

### 6. 信号量
   信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。
   为了正确地实现信号量，信号量值的测试及减1操作应当是**原子操作**。为此，信号量通常是在内核中实现的。

### 7. Socket
   套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。
* 需要通信的进程之间首先要各自创建一个 socket，内容包括主机地址与端口号，声明自己接收来自某端口地址的数据
* 进程通过 socket 把消息发送到网络层中，网络层通过主机地址将其发到目的主机，目的主机通过端口号发给对应进程
* 操作系统提供创建 socket、发送、接收的系统调用，为每个 socket 设置发送缓冲区、接收缓冲区。

## 进程同步

## 进程的调度

### 进程状态
进程的基本状态：“就绪”、“执行”、“阻塞”。

* 就绪：进程已获得除处理机以外的所需资源，等待分配处理机资源(等待CPU时间片)
* 执行：进程正在占用处理机资源执行
* 阻塞：进程等待某种条件，在条件满足之前无法执行。如发起了 I/O 系统调用，会被阻塞，等待 I/O 中断发生(等待资源)
>注意：只有就绪态和运行态可以相互转换，其他都是单向转换

![](https://imageslr.com/media/15941900183711.jpg)

**挂起**

“挂起”是指将暂不执行的进程换出到外存，节省内存空间。

“挂起”和“阻塞”都是进程暂停执行的状态，但是这是两个维度的概念：

* 阻塞表示进程正在等待一个事件的发生，阻塞状态下收到收到信号会切换为就绪状态
* 挂起表示进程被换出到外存，挂起状态下被激活时会被载入到内存，切换为非挂起状态

综上所属，挂起状态的进程按照是否阻塞可以分为：

* 挂起就绪状态：进程在外存中，但是只要被载入内存就可以执行
* 挂起阻塞状态：进程在外存中并等待一个事件，即使被载入内存（激活）也无法运行

**睡眠**

Linux 将进程的阻塞状态进一步细分为：暂停、浅睡眠、深睡眠。其中，若不需要等待资源，则切换为“暂停”；若需要等待资源，切换为“睡眠”；如果睡眠状态能被信号唤醒，则是“浅睡眠”，否则是“深睡眠”。

![](https://imageslr.com/media/15941904147999.jpg)
### 调度算法

* 按照 CPU 的分配方式：非抢占式、抢占式
* 按照系统的分时方式：在批处理系统，交互系统或实时系统下的调度

#### 批处理系统的调度方式

**调度算法目标**：保证吞吐量和周转时间，提高CPU利用率

1. **先来先服务（First Come First Serverd，FCFS）**
   * 非抢占式的调度算法，按照请求的顺序进行调度。
   * 缺点是对短作业不公平；对 I/O 密集型进程不利，长时间等待设备

2. **短作业优先（Shortest Job First，SJF）**
   * 非抢占式的调度算法，按估计运行时间最短的顺序进行调度。
   * 对长作业不公平；可能导致饥饿问题

3. **最短剩余时间优先（Shortest Remaining Time Next，SRTN）**
   * 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。如果新作业比正在执行的作业剩余时间短，则它优先执行
   * 缺点是对长作业不公平；可能导致饥饿问题。同“最短作业优先”

4. **最高响应比优先算法（Highest Response Ratio Next，HRRN）**
   * 响应比的定义：作业等待时间/作业运行所需时间
   * 哪个进程的响应比大，哪个进程优先
   * 优点：同时考虑了等待时间和执行时间，既优先考虑短作业，也防止长作业无限等待的饥饿


#### 交互式系统的调度方式

**调度算法目标：** 响应时间快，将CPU分为若干个时间片，处理不同的运算请求，使每个用户都能共享主机资源

1. **时间片轮转（Round Robin，RR）**
   
* 将所有就绪进程按 FCFS 的原则排成一个队列，按照时间片轮流调度，用完实践篇的进程排到队列末尾，属于抢占式
* 优点：没有饥饿问题
* 问题：若时间片小，进程切换频繁，吞吐量低；若时间片长，则响应时间过长，实时性得不到保证

2. **优先级调度（Priority）**
   
* 优先级高的进程先运行，同优先级的进程轮转。当高优先级队列中没有进程后，再调度下一级队列
* 缺点是可能导致低优先级进程饿死

3. **多级反馈队列（Multilevel Feedback Queue，MFQ）**

* 设置多个队列，优先级从高到低，时间片从小到大分配；如果一个进程在当前队列规定的时间片内无法执行完毕，则移动到下一个队列的队尾
* 缺点：也有可能出现饥饿问题，比如不断有新的更高优先级的进程加入

4. **彩票法**
* 向进程提供各种系统资源的彩票。调度时随机抽取彩票，拥有该彩票的进程得到资源
* 可给重要的进程更多的彩票；协作进程可以交换彩票

5. **公平分享法**
* 为每用户分配一定比例的 CPU 时间，而不是按照进程
* 各用户之间按照比例挑选进程

#### 实时系统的调度方式

**调度算法目标**：满足任务的截止时间。也就是说，如果有一个任务需要执行，实时操作系统会马上执行该任务，不会有较长的延时。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

#### Linux的进程调度
Linux 标准内核实现两个调度类：采用 **CFS 调度算法的默认调度类和实时调度类**。
##### CFS

CFS使用`vruntime`来记录进程的虚拟执行时间，该值通过进程调度优先级(如nice值)与实际进程执行时间加权所得。

##### 实时调度

Linux 也实现了实时调度。采用 **SCHED_FIFO** 或 **SCHED_RR** 实时策略来调度的任何任务，与普通（非实时的）任务相比，具有更高的优先级。


>nice值：值进程的友好度，越高代表越乐意把cpu让给其他进程，即优先级越低

### 僵尸进程，孤儿进程

当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。进程会保持在一种“已终止”的状态中，直到被它的父进程回收。当父进程回收已终止的子进程时，内核会抛弃已终止的进程，此时该进程就不存在了。

**僵尸进程**

僵尸进程是指终止但还未被回收的进程。如果子进程退出，而父进程并没有调用 wait() 或 waitpid() 来回收，那么就会产生僵尸进程。僵尸进程是一个已经死亡的进程，但是其进程描述符仍然保存在系统的进程表中。

危害：占用进程号，系统所能使用的进程号是有限的，可能导致不能产生新的进程；占用一定的内存。

如何避免产生僵尸进程：

* 父进程调用 wait 或者 waitpid 等待子进程结束
* 子进程结束时，内核会发生 SIGCHLD 信号给父进程。父进程可以注册一个信号处理函数，在该函数中调用 waitpid，等待所有结束的子进程；也可以用 signal(SIGCLD, SIG_IGN) 忽略 SIGCHLD 信号，那么子进程结束后，内核会进行回收
* 杀死父进程，僵尸进程就会变成孤儿进程，由 Init 进程接管并处理

**孤儿进程**

如果某个进程的父进程先结束了，那么它的子进程会成为孤儿进程每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用 Init 进程（pid = 1）接管，并由 Init 进程调用 wait 等待其结束，完成状态收集工作。孤儿进程不会对系统造成危害。

## 参考
https://www.jianshu.com/p/c1015f5ffa74