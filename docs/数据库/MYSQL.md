## 存储引擎

**概念**：作为数据库的底层，负责数据的存储与提取。简单来说，存储引擎是为数据库提供创建、查询、更新、存储数据的软件模块。不同的存储引擎的主要区别是数据的存储方式，此外功能、特性、速度等也有所差异。

### MYSQL支持的存储引擎
执行`show engines`查看，MSYQL5.5之后默认的存储引擎是InnoDB,只有它支持事务，之前版本是MyISAM.

#### InnoDB
最广泛使用，支持事务，支持行级锁，崩溃恢复和MVCC，满足ACID约束。

**存储结构**

InnoDB 将表结构存储在 .frm 文件中，数据和索引存储在 .idb 文件中。.idb 文件是由 InnoDB 管理的特殊格式的数据文件，表示每一个表独有的表空间（tablespace）。

在表空间中，所有的数据记录都被逻辑地存放在表空间中。表空间被进一步划分为段（segment）、区（extent）、页（page）。页是 InnoDB 管理数据的最小磁盘单位，每个 16KB 大小的页中可以存放 2-200 行的记录。

InnoDB 的行记录在物理存储上并不是顺序的。为了保证插入和删除的效率，整个页面并不会按照主键顺序对行记录进行排序，而是自动从左向右寻找空白节点进行插入，通过行记录中的 next_record 指针表示它们之间的逻辑顺序。

InnoDB 在查找某条记录时，并不能直接找到对应的行记录，而是只能获取到记录所在的页，然后将整个页面加载到内存中，在内存中遍历找到具体行。

#### MyISAM

不支持事务，也不支持行级锁，只支持表级锁

**存储结构**

MyISAM将表结构存储在.frm文件中，数据存储在.MYD文件，索引存储在.MYI文件

不同于 InnoDB，MyISAM 的数据是顺序存储的，索引的 B+ 树叶节点存放数据记录的地址，可以直接定位到数据，因此查找速度很快

#### Memory
基于内存，读写速度快。进程崩溃或者重启的话数据会丢失，故安全性不高

适用于对读写速度要求高且数据库表相对小且数据安全性要求低

#### 综合对比

|   特性   | InnoDB | MyISAM | Memory |
| :------: | :----: | :----: | :----: |
|   事务   |  支持  | 不支持 | 不支持 |
|   外键   |   ✔️    |   ✖️    |   ✖️    |
|  锁机制  | 行级锁 | 表级锁 | 表级锁 |
|   MVCC   |   ✔️    |   ✖️    |   ✖️    |
| B树索引  |   ✔️    |   ✔️    |   ✔️    |
| 哈希索引 |   ✖️    |   ✖️    |   ✔️    |
| 空间使用 |   高   |   低   |  N/A   |
| 查询速度 |   慢   |   快   |   快   |
| 插入速度 |   慢   |   快   |   快   |

## 索引

**概念**：

索引是一种特殊的文件，包含着对数据表所有记录的引用指针，用于快速查询，更新数据库表数据。通俗来说，索引相当于目录，且需要占据物理空间。

**索引的优点**

* 加快数据检索速度，提高系统性能
* 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性
* 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）

**索引的缺点**

* 创建和维护索引要耗费时间，当对表中数据进行增加，删除和修改时，索引需要动态维护，降低增删改的执行效率。
* 占据物理空间

### 如何创建
1. `ALTER TABLE table_name ADD INDEX index_name(column_list)`
2. `CREATE INDEX index_name ON table_name(column_list)`
3. CREATE TABLE时创建
### 索引的类型

#### 从存储结构划分

1. **B+Tree索引(大多数MySQL存储引擎的默认索引类型)**

   因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。

   InnoDB默认使用B+树作为索引，分为主索引和辅助索引。
>关于B+树和B-树结构，请看[]()
   主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

   辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

2. **Hash索引**
   
   哈希索引能以 O(1) 时间进行查找，但是失去了有序性：
   只支持精确查找，不支持范围查找

3. **full-index全文索引**
   
   全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。
4. **R-Tree索引**
   
   MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

#### 从应用层次划分

1. **聚簇索引和非聚簇索引**(严格来说不属于索引的范畴，是一种数据的组织方式)
   * **聚簇索引**:InnoDB将主键和数据组织在一起，并且将数据保存在叶子节点
   * **非聚簇索引**(二级索引):也叫辅助索引，二级索引不保存行数据，仅保存索引数据，叶子节点仅保存主键
   
   **查询过程**：
   * **主键查询**:直接在聚簇索引中查找，叶子节点保存着数据
   * **普通索引查询**：通过索引树找到对应主键，再去聚簇索引中查找数据，这个过程称为**回表**

>关于聚簇索引的组织方式：
>1. 若表中指定了主键，那么主键作为聚簇索引的组织方式
>2. 若表中未指定主键，那么InnoDB会选择一个 UNIQUE NOT NULL的费控唯一索引作为聚簇索引的组织方式
>3. 如果两者都没有，InnoDB会生成一个隐藏的主键
   
2. **普通索引和唯一索引**
   * **普通索引**：一个索引只包含单个列，一个表可以有多个单列索引
   * **唯一索引**：索引列的值必须唯一，但允许有空值

   **关于查询**

   * **普通索引**：顺着索引树查找到某条数据时，还需向后查找，判断是否有其他数据为该值
   * **唯一索引**：找到数据直接返回，因为索引为unique的，不会重复
  >两者效率几乎相同，因为B+Tree按页读取，数据具有相邻特性

   **关于更新**
   * **普通索引**：如果更新的页不在内存中，写入到`Change buffer` 中
   * **唯一索引**：如果更新的页不在内存中，由于需要唯一性检查，需要把page读到内存中判断后操作
   >在page不在内存中情况，普通索引效率高于唯一索引

   >Change Buffer：如果更新数据的page不在内存中，且不会影响数据一致性前提下，InnoDB会把修改写入Change Buffer，随后读取该行数据时，将数据读入内存，然后执行merge操作合并

3. **覆盖索引**
   
    指不需要进行回表，即只查询一颗B+Tree就可找到所需要的数据

    如：select count(*) from T,当表中存在二级索引时，MySQL会直接统计二级索引数目，不需要去聚簇索引中遍历

    又如：有联合索引(mobile,name)，如果使用mobile查询name，同样不需要回表。

4. **联合索引**
   
    顾名思义，多列值组合成的索引，如果建立了(a,b,c)三个字段的索引，相当于有了(a),(a,b),(a,b,c)这三个索引。

    补充:
   >最左前缀原则:匹配联合索引的前N个字段

   >索引下推:可以减少回表次数，只针对二级索引有效,默认开启
   设有二级索引(a,b,c),查询语句为 `select * from t where a='xxx' and b like '%xxx%' and c like '%xxx%'`

   >如果没有使用索引下推，MySQL会从`a='xxx'`查询对应数据，返回服务端，然后服务端基于`b like '%xxx%' and c like '%xxx%`判断数据是否符合条件

   >如果使用了索引下推，MySQL会返回符合`a='xxx'`的索引，然后根据`b like '%xxx%' and c like '%xxx%`判断是否符合条件，符合的再来定位

### 创建索引注意事项
1. 非空字段：在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替NULL；
2. 索引字段越小越好
3. 被频繁查询字段
4. 频繁需要排序的字段
5. 选择数据密度大（唯一值占总数的百分比很大）的字段作索引

### 索引失效情况
1. !=或者<>
2. 类型不一致
3. 函数，如DATE(字段)
4. 运算符,会导致隐式转换
5. OR,如果连接的是同一字段则不会失效
6. 模糊搜索:如果%放在后面(xx%)，会走索引
7. NOT IN,NOT EXISTS
