
## 多版本并发控制(MVCC)

### **概念**

多版本并发控制（Multi-Version Concurrency Control, MVCC），MVCC在每行记录后面都保存有两个隐藏的列，用来存储创建版本号和删除版本号。

### 实现原理

InnoDB聚簇索引记录中包含3个隐藏的列：

* ROW ID:隐藏的自增ID，如果表没有主键，InnoDB会自动按ROW ID产生 一个聚集索引树。
* TRX ID:记录最后一次修改该记录的事务ID
* 回滚指针：指向这条记录的上一个版本（undo log）

InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指启动但未提交。

数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1
记为高水位。

![](https://community-header-1306990603.cos.ap-guangzhou.myqcloud.com/20220223220816.png)

这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：
1. 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数
据是可见的；
2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3. 如果落在黄色部分，那就包括两种情况 
   1. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见； 
   2. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。

* **当前读**:读取的是记录的最新版本，读取时保证其他并发事务不能修改当前记录，会对读取的记录加锁,例如：(共享锁，排它锁)
* **快照读**:像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。


### **MVCC优点**:
* 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
* 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题

### 对于幻读

InnoDB存储引擎在 RR 级别下通过 MVCC和 Next-key Lock 来解决幻读问题：

**1、执行普通 select，此时会以 MVCC 快照读的方式读取数据**

在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成` Read View `，并使用至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读” 

**2、执行 select...for update/lock in share mode、insert、update、delete 等当前读**

在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！`InnoDB` 使用` Next-key Lock  (opens new window)` 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读
