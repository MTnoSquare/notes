## 二分

* 当` check(mid) == true `调整的是` l `时：计算 mid 的方式应该为 `mid = l + r + 1 >> 1`：
```java
//模板1
    long l = 0, r = 1000009;
    while (l < r) {
    long mid = l + r + 1 >> 1;
    if (check(mid)) {
        l = mid;
    } else {
        r = mid - 1;
    }
}
```

* 当 `check(mid) == true` 调整的是 `r` 时：计算 mid 的方式应该为 `mid = l + r  >> 1`：
```java
//模板2
    long l = 0, r = 1000009;
    while (l < r) {
    long mid = l + r >> 1;
    if (check(mid)) {
        r = mid;
    } else {
        l = mid + 1;
    }
}
```

* 为什么修改左边指针 l 的时候要进行 +1 操作？

「模板一」的 +1 操作主要是为了避免发生「死循环」，因为 >> 和 直接使用 / 一样，都属于「下取整」操作。

考虑 l = 0, r = 1 的简单情况，如果不 +1 的话，l + r >> 1 等于 0 + 1 / 2，l 仍然是 0，陷入死循环。


## 滑动窗口
```java

```

## 并查集
并查集 (Disjoint-set data structure / union–find data structure / merge–find set) 是一种树形的数据结构，顾名思义，它用于处理一些不交集的合并及查询问题。 它支持两种操作：

查找 ( Find ) ：确定某个元素处于哪个子集；

合并 ( Union ) ：将两个子集合并成一个集合。



「路径压缩」：在并查集中查找代表元素时，会将经过的所有元素「直接」连接到代表元素，也就是将连通分量「压扁」。

「按秩合并」：在并查集中合并两个连通分量时，将「秩」小的连通分量合并到「秩」大的连通分量上面。这里「秩」可以定义为连通分量的大小（包含的节点数量），或者连通分量的高度（连通分量是树的结构，因此可以定义高度。不过在「路径压缩」优化的基础上，这个高度会不断减小，但我们不用去时刻维护它，这样也可以达到最优的时间复杂度是已经被证明的了）。
两者都是为了优化 Find 和 Union 的时间复杂度而提出的优化算法。

```java
    public int find(int []parents,int index){
        if(parents[index]!=index)
        parents[index]=find(parents,parents[index]);
        return parents[index];
    }
    
    public void union(int []parents,int i,int j){
        parents[find(parents,i)]=find(parents,j);
    }

```
## 输入输出
```java
import java.io.*;

public class Main {
	public static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in),32768));
	public static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));

	public static double nextDouble() throws IOException{
        in.nextToken();
        return in.nval;
        }
	public static float nextFloat() throws IOException{ 
        in.nextToken();
        return (float)in.nval;
        }
	public static int nextInt() throws IOException{
        in.nextToken();
        return (int)in.nval;
        }
	public static String next() throws IOException{
        in.nextToken();
        return in.sval;
        }

	public static void main(String[] args) throws IOException{
//		获取输入
		while(in.nextToken()!=StreamTokenizer.TT_EOF){
			break;
		}
		int x = (int)in.nval;  
		int y = nextInt();
		float f = nextFloat();
		double d = nextDouble();
		String str = next();

//		输出
		out.println("abc");
		out.flush();
		out.close();
	}
}


```