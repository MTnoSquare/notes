## 排序的稳定性

待排序的记录序列中可能存在两个或两个以上关键字相等的记录。排序前的序列中 Ri 领先于 Rj(即 i < j ),若在排序后的序列中 Ri 仍然领先于 Rj，则称所用的方法是稳定的。比如 int 数组[1,1,1,6,4]中 a[0],a[1],a[2]的值相等，在排序时不改变其序列，则称所用的方法是稳定的。

## 比较

|   排序方法   | 平均时间复杂度 | 最优时间复杂度 | 最坏时间复杂度 |  空间复杂度  | 稳定性 |
| :----------: | :------------: | :------------: | :------------: | :----------: | :----: |
| **插入排序** |    O($n^2$)    |     O($n$)     |    O($n^2$)    |     O(1)     |  稳定  |
| **冒泡排序** |    O($n^2$)    |     O($n$)     |    O($n^2$)    |     O(1)     |  稳定  |
| **归并排序** |  O($nlog_2n$)  |  O($nlog_2n$)  |  O($nlog_2n$)  |    O($n$)    |  稳定  |
| **快速排序** |  O($nlog_2n$)  |  O($nlog_2n$)  |    O($n^2$)    | O($nlog_2n$) | 不稳定 |
|  **堆排序**  |  O($nlog_2n$)  |  O($nlog_2n$)  |  O($nlog_2n$)  |    O($1$)    | 不稳定 |
| **选择排序** |    O($n^2$)    |    O($n^2$)    |    O($n^2$)    |     O(1)     | 不稳定 |



## 使用场景

## 各个排序算法详细

- [插入排序](/LeetCode/排序/插入排序.md)
- [冒泡排序](/LeetCode/排序/冒泡排序.md)
- [归并排序](/LeetCode/排序/归并排序.md)
- [快速排序](/LeetCode/排序/快速排序.md)
- [堆排序](/LeetCode/排序/堆排序.md)
- [选择排序](/LeetCode/排序/选择排序.md)
