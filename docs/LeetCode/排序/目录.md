## 排序的稳定性

待排序的记录序列中可能存在两个或两个以上关键字相等的记录。排序前的序列中 Ri 领先于 Rj(即 i < j ),若在排序后的序列中 Ri 仍然领先于 Rj，则称所用的方法是稳定的。比如 int 数组[1,1,1,6,4]中 a[0],a[1],a[2]的值相等，在排序时不改变其序列，则称所用的方法是稳定的。

## 比较

|   排序方法   | 平均时间复杂度 | 最优时间复杂度 | 最坏时间复杂度 |  空间复杂度  | 稳定性 |
| :----------: | :------------: | :------------: | :------------: | :----------: | :----: |
| **插入排序** |    O($n^2$)    |     O($n$)     |    O($n^2$)    |     O(1)     |  稳定  |
| **冒泡排序** |    O($n^2$)    |     O($n$)     |    O($n^2$)    |     O(1)     |  稳定  |
| **归并排序** |  O($nlog_2n$)  |  O($nlog_2n$)  |  O($nlog_2n$)  |    O($n$)    |  稳定  |
| **快速排序** |  O($nlog_2n$)  |  O($nlog_2n$)  |    O($n^2$)    | O($nlog_2n$) | 不稳定 |
|  **堆排序**  |  O($nlog_2n$)  |  O($nlog_2n$)  |  O($nlog_2n$)  |    O($1$)    | 不稳定 |
| **选择排序** |    O($n^2$)    |    O($n^2$)    |    O($n^2$)    |     O(1)     | 不稳定 |



## 使用场景

1. 若 n 较小(如 n≤50)，可采用`直接插入`或`直接选择排序`。
2. 若文件初始状态基本有序，则应选用`直接插入、冒泡或随机`的快速排序。
3. 若 n 较大，则应采用时间复杂度为 O(nlogn) 的排序方法：快速排序、堆排序或归并排序。
    1. 当待排序的关键字是`随机分布`时，快速排序的平均时间最短。   
    2. 堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。
    3. 若要求排序稳定，则可选用归并排序。，归并排序需要较大的额外空间，但归并排序可以多路归并。
    4. 相比于从长度为 1 的序列开始归并，归并排序也可以和直接插入排序结合使用，先通过直接插入排序获得较长的有序序列，然后再进行归并。这种方式依然是稳定的。
4. 大部分情况可以直接使用快速排序。
5. 当待排序的关键字无法全部加载到内存中时，需要使用归并排序进行外部排序。

## 各个排序算法详细

- [插入排序](/LeetCode/排序/插入排序.md)
- [冒泡排序](/LeetCode/排序/冒泡排序.md)
- [归并排序](/LeetCode/排序/归并排序.md)
- [快速排序](/LeetCode/排序/快速排序.md)
- [堆排序](/LeetCode/排序/堆排序.md)
- [选择排序](/LeetCode/排序/选择排序.md)
- [TODO]