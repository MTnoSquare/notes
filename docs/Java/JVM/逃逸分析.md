
## 逃逸分析

分析对象的动态作用域，最终目的就是为程序做优化，提高运行性能。

* **方法逃逸**：对象在方法中被定义，但却被方法以外的其他代码使用，如传参到其他方法中等可能导致此情况发生
* **线程逃逸**：一个对象由某个线程在方法中被定义，但却被其他线程访问，如类变量，有get，set方法的实例变量等

如果对象不会发生前述方法逃逸和线程逃逸情况（即完全不可能被别的方法和线程访问到的对象），JVM 可做以下优化：

1. **栈上分配**

    当确定对象不会发生方法逃逸时，可在线程栈上分配对象。此时对象生命周期和方法相同，随栈帧出栈时即可销毁，不需要 GC 了。

2. **同步消除**

    **锁消除**：当确定对象不会发生线程逃逸时，可消除该对象不必要的同步操作（永不会竞争）。具体来说，JVM 在编译器运行时会扫描代码，当检查到那些不可能存在共享区竞争，但却有互斥同步的代码，直接将这样的多此一举的同步消除

    **锁粗化**：JVM 针对那些反复在一段代码中对同一对象加锁的情况，将同步锁放在最外层包住这里面的多次同步锁，同时取消内部的同步锁

3. **标量替换**

    >**标量**:指无法分解的数据，如 java 中的基本数据类型及引用类型  
    >**聚合量**：可以再分解成其他聚合量或者标量的数据类型，例如对象引用类型。

    如果一个可拆分对象不会发生逃逸，那在程序执行时并不创建他，而是根据情况在线程栈上只创建用到的成员标量,节约了空间和时间。