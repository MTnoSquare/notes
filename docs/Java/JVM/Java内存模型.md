## 硬件的效率与一致性

由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

![](https://community-header-1306990603.cos.ap-guangzhou.myqcloud.com/20220311171523.png)

除了增加高速缓存之外，**为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入
代码进行乱序执行（Out-Of-Order Execution）优化**，处理器会在计算之后将乱序执行的结果重组，保
证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺
序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码
的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有指令重排序
（Instruction Reorder）优化。

## Java内存模型（JMM)

>**作用**:屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

### 主内存与工作内存

![](https://community-header-1306990603.cos.ap-guangzhou.myqcloud.com/20220311171733.png)

Java内存模型规定了所有的变量(不包括局部变量和方法参数,因为线程私有)都存储在主内存（Main Memory）中.线程的工作内存中保存了被该线程使用的变量的主内存副本，**线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行**，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图所示.

### 内存间交互操作

一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下8种操作来完成。(基本上每种操作都是原子性的).

1. **lock(锁定)**:作用于主内存的变量，它把一个变量标识为一条线程独占的状态。

2. **unlock(解锁)**:作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量
才可以被其他线程锁定。

3. **read（读取）**:作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以
便随后的load动作使用。

4. **load（载入）**：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的
变量副本中。

5. **use（使用）**：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚
拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。

6. **assign（赋值）**：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，
每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。

7. **store（存储）**：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随
后的write操作使用。

8. **write（写入）**：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的
变量中。

>基于理解难度和严谨性考虑，最新的JSR-133文档中，已经放弃了采用这8种操作去定义Java内存模型的访问协议，缩减为4种（仅是描述方式改变了，Java内存模型并没有改变）。

### volatile

被volatile修饰的变量具备两项特性
1. 保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。
2. 禁止指令重排序优化,volatile相当于给变量加了一个内存屏障,重排序时不能把后面的指令重排序到内存屏障之前的位置,只有一个处理器访问内存时，并不需要内存屏障；但如果有两个或更多处理器访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。

### 先行发生原则（Happens-Before）

>它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型苦涩难懂的定义之中。

下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已
经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出
来，则它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。

1. **程序次序规则（Program Order Rule）**：在一个线程内，按照控制流顺序，书写在前面的操作先行
发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循
环等结构。
2. **管程锁定规则（Monitor Lock Rule）**：一个unlock操作先行发生于后面对同一个锁的lock操作。这
里必须强调的是“同一个锁”，而“后面”是指时间上的先后。
3. **volatile变量规则（Volatile Variable Rule）**：对一个volatile变量的写操作先行发生于后面对这个变量
的读操作，这里的“后面”同样是指时间上的先后。
4. **线程启动规则（Thread Start Rule）**：Thread对象的start()方法先行发生于此线程的每一个动作。
5. **线程终止规则（Thread Termination Rule）**：线程中的所有操作都先行发生于对此线程的终止检
测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止
执行。
6. **线程中断规则（Thread Interruption Rule）**：对线程interrupt()方法的调用先行发生于被中断线程
的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。
7. **对象终结规则（Finalizer Rule）**：一个对象的初始化完成（构造函数执行结束）先行发生于它的
finalize()方法的开始。
8. **传递性（Transitivity）**：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出
操作A先行发生于操作C的结论。



