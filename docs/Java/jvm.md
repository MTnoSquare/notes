## 字节码
## 各项命令
**jps**

打印所有正在运行的Java进程的相关信息，如进程ID以及主类名

```
-l：打印模块名以及包名
```

如果某Java进程关闭了默认开启的UsePerfData参数（即使用参数-XX:-UsePerfData），那么jps命令（以及下面介绍的jstat）将无法探知该 Java 进程。

**jstat**

允许用户查看目标 Java 进程的类加载、即时编译以及垃圾回收相关的信息。它常
用于检测垃圾回收问题以及内存泄漏问题。
```
-class:打印类加载相关的数据
-compiler和-printcompilation：打印即时编译相关的数据。
```

**jmap**

允许用户统计目标 Java 进程的堆中存放的 Java 对象，并将它们导出成二进制文
件。

```
 -dump:该子命令将导出 Java 虚拟机堆的快照。同样，-dump:live只保存堆中的存活
对象。

-clstats:该子命令将打印被加载类的信息。

-histo:该子命令将统计各个类的实例数目以及占用内存，并按照内存使用量从多至少
的顺序排列。此外，-histo:live只统计堆中的存活对象。

```

**jinfo**

打印目标 Java 进程的配置参数，并能够改动其中 manageabe 的参数。


**jstack**

打印目标 Java 进程中各个线程的栈轨迹、线程状态、锁状况等信息。它还将
自动检测死锁。

**jcmd**

实现前面除了jstat之外所有命令的功能。

## 逃逸分析

分析对象的动态作用域，最终目的就是为程序做优化，提高运行性能。

* **方法逃逸**：对象在方法中被定义，但却被方法以外的其他代码使用，如传参到其他方法中等可能导致此情况发生
* **线程逃逸**：一个对象由某个线程在方法中被定义，但却被其他线程访问，如类变量，有get，set方法的实例变量等

如果对象不会发生前述方法逃逸和线程逃逸情况（即完全不可能被别的方法和线程访问到的对象），JVM 可做以下优化：

1. **栈上分配**

    当确定对象不会发生方法逃逸时，可在线程栈上分配对象。此时对象生命周期和方法相同，随栈帧出栈时即可销毁，不需要 GC 了。

2. **同步消除**

    **锁消除**：当确定对象不会发生线程逃逸时，可消除该对象不必要的同步操作（永不会竞争）。具体来说，JVM 在编译器运行时会扫描代码，当检查到那些不可能存在共享区竞争，但却有互斥同步的代码，直接将这样的多此一举的同步消除

    **锁粗化**：JVM 针对那些反复在一段代码中对同一对象加锁的情况，将同步锁放在最外层包住这里面的多次同步锁，同时取消内部的同步锁

3. **标量替换**

    >**标量**:指无法分解的数据，如 java 中的基本数据类型及引用类型  
    >**聚合量**：可以再分解成其他聚合量或者标量的数据类型，例如对象引用类型。

    如果一个可拆分对象不会发生逃逸，那在程序执行时并不创建他，而是根据情况在线程栈上只创建用到的成员标量,节约了空间和时间。