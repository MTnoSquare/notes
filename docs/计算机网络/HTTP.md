## HTTP基本知识
HTTP是一种**超文本传输协议**
### 常见的状态码


状态码分为五大类
 
|       |                 具体含义                  |  常见的状态码   |
| :---: | :---------------------------------------: | :-------------: |
|  1xx  |   提示信息，表示中间状态，还有后续操作    |                 |
|  2xx  |       成功，报文已被收到并正确处理        |   200,204,206   |
|  3xx  |         重定向，资源位置发生变动          |   301,302,304   |
|  4xx  |         客户端错误，请求报文有误          |   400,403,404   |
|  5xx  | 服务器错误,服务器在处理请求时内部发生错误 | 500,501,503,503 |


#### 1xx信息响应

信息响应  
100 Continue  
这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。  

#### 2xx成功响应
**200 OK**  
请求成功。成功的含义取决于HTTP方法：
* GET：资源已被提取并在消息正文中传输。
* HEAD：实体标头位于消息正文中。
* POST：描述动作结果的资源在消息体中传输。
* TRACE：消息正文包含服务器收到的请求消息

**201 Created**  
该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。

**204 No Content**  
服务器成功处理了请求，但响应头没有body数据，通常用于只需要从客户端往服务器发送信息，而不需要返回数据时

**206 Partial Content**  
服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。
#### 3xx重定向

**300 Multiple Choice**  
被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。

**301 Moved Permanently**  
表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。

**302 Found**  
表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。

**303 See Other**  
对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。

**304 Not Modified**  
如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。

**307 Temporary Redirect**  
临时重定向。307 与 302 之间的唯一区别在于，当发送重定向请求的时候，307 状态码可以确保请求方法和消息主体不会发生变化；而如果使用 302 响应状态码，一些旧客户端会错误地将请求方法转换为 GET
#### 4xx客户端错误
 
**400 Bad Request**  
1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。
2、请求参数有误。

**401 Unauthorized**  
当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。

**402 Payment Required**  
此响应码保留以便将来使用，创造此响应码的最初目的是用于数字支付系统，然而现在并未使用。

**403 Forbidden**  
服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。

**404 Not Found**  
请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。
#### 5xx服务端错误
 
**500 Internal Server Error**  
服务器遇到了不知道如何处理的情况。

**501 Not Implemented**  
此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。

**502 Bad Gateway**  
此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。

**503 Service Unavailable**  
服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 Retry-After：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。

**504 Gateway Timeout**  
当服务器作为网关，不能及时得到响应时返回此错误代码。

**505 HTTP Version Not Supported**  
服务器不支持请求中所使用的HTTP协议版本。

### HTTP常见标头
**Cache-Control**:管理如何对HTTP的请求或者响应使用缓存。

**Host**：客户端发送请求时，⽤来指定服务器的域名

**Content-Length**:服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据⻓度。

**Connection**:最常⽤于客户端要求服务器使⽤ TCP 持久连接，以便其他请求复⽤。**HTTP/1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection⾸部字段的值为**`Keep-Alive `

**Content-Type**：⽤于服务器回应时，告诉客户端，本次数据是什么格式。客户端请求的时候，可以使⽤ `Accept `字段声明⾃⼰可以接受哪些数据格式。

**Content-Encoding**：说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式。客户端在请求时，⽤ `Accept-Encoding `字段说明⾃⼰可以接受哪些压缩⽅法。

### HTTP请求方法

>HTTP 请求方法表明了要对给定资源执行的操作，每一个请求方法都实现了不同的语义。包括：GET、HEAD、POST、PUT、PATCH、DELETE、OPTIONS，以及不常用的 CONNECT、TRACE。

**GET**：获取服务器的指定资源

**HEAD**：与 GET 方法一样，都是发出一个获取服务器指定资源的请求，但服务器只会返回 Header 而不会返回 Body。用于确认 URI 的有效性及资源更新的日期时间等。一个典型应用是下载文件时，先通过 HEAD 方法获取 Header，从中读取文件大小 Content-Length；然后再配合 Range 字段，分片下载服务器资源

**POST**：提交资源到服务器 / 在服务器新建资源

**PUT**：替换整个目标资源

**PATCH**：替换目标资源的部分内容

**DELETE**：删除指定的资源

**OPTIONS**：用于描述目标资源的通信选项。可以用于检测服务器支持哪些 HTTP 方法，或者在 CORS 中发起一个预检请求，以检测实际请求是否可以被服务器所接受

**CONNECT**：建立一个到由目标资源标识的服务器的隧道

**TRACE**：执行一个消息环回测试，返回到服务端的路径。客户端请求连接到目标服务器时可能会通过代理中转，通过 TRACE 方法可以查询发送出去的请求的一系列操作
### GET和POST

>幂等:意思是多次执⾏相同的操作，结果都是「相同」的  
>安全:在 HTTP 协议⾥，所谓的「安全」是指请求⽅法不会「破坏」服务器上的资源。

|                 |                   GET                    |               POST                |
| :-------------: | :--------------------------------------: | :-------------------------------: |
|      应用       |           获取服务器的指定数据           |      添加 / 修改服务器的数据      |
| 历史记录 / 书签 | 可保留在浏览器历史记录中，或者收藏为书签 |              不可以               |
|      缓存       |              会被浏览器缓存              |             不会缓存              |
|      幂等       |       幂等，不会改变服务器上的资源       |  非幂等，会对服务器资源进行改变   |
|   后退 / 刷新   |        后退或刷新时，GET 是无害的        | 后退或刷新时，POST 会重新提交表单 |
|    参数位置     |     query 中（直接明文暴露在链接中）     |         query 或 body 中          |
|    参数长度     |            2KB（2048 个字符）            |              无限制               |

### HTTP缓存

HTTP缓存有几种不同的类型，可以分为两个主要类别：`私有缓存`和`共享缓存`。
* 共享缓存：存储多个用户重复使用的请求/响应
* 私有缓存：适用于单个用户
### Cookie
Cookie包括Web Cookie和浏览器Cookie，用来保存状态信息

**1. 用途**
* 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
* 个性化设置（如用户自定义设置、主题等）
* 浏览器行为跟踪（如跟踪分析用户行为等）



**2. 分类**
  1. 会话Cookie
   
   客户端关闭时会被删除

  2. 永久Cookie
   通过指定特定日期(Expires)和特定时间长度(Max-Age)来过期

**3.作用域**

`Domain`和`Path`标识定义了Cookie的作用域，即Cookie应该发给哪些URL

`Domain`指定主机，`Path`指定了哪些路径

**4.Cookie和Session**

二者都是用来跟踪浏览器用户身份的会话方式。

**Cookie：**

* 存在浏览器里，可以设置过期时间
* 每次访问服务器时，浏览器会自动在 header 中携带 cookie
* 如果浏览器禁用了 cookie，可以使用 URL 重写机制，将信息保存在 URL 里

**Session:**

* 存在服务端，由服务器维护，一段时间后 session 就失效了
* 本质上，session 还是通过 cookie 实现的。浏览器的 cookie 中只保存一个 sessionId，所有其他信息均保存在服务端，由 sessionId 标识
* Session 失效，其实是服务器设置了失效时间。如果用户长时间不和服务器交互（比如 30 分钟），那么 session 就会被销毁；交互的话，就会刷新 session

### token

**概念**：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。


* 每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里
* token 完全由应用管理，所以它可以避开同源策略

### JWT
Json Web Token的简称，主要用来进行**认证**和**信息交换**

**格式**
JWT由三部分组成
* Header：令牌的类型和使用的前面算法
* Payload:用户数据的声明
* Signature:签证信息，由Base64Url编码后得到的header和payload以及secret组成，用于验证消息是否被修改过。

JWT和Session的不同
* JWT具有加密签名，Session没有
* JWY无状态，存储在客户端，身份验证可以在本地进行，无需查库
* 支持跨域

## HTTP各版本演变以及特性

### HTTP1.0

默认使用短连接:浏览器每请求一个静态资源，就建立一次连接，任务结束就中断连接

无状态，明文传输，不安全
### HTTP1.1
**优点：**

* 默认支持长连接
* 支持管道网络传输，第一个请求发出去不必等待其响应就可发第二个，减少整体的响应时间。

**缺点：**

* 请求/响应头部(Header)未经压缩就发送，首部信息越多延迟越大。只能压缩`Body`部分
* 服务器按请求顺序响应，容易导致客户端长等待
* 没有请求优先级控制
* 请求只能从客户端发起，服务端被动响应

### HTTP2
基于HTTPS，针对HTTP1.1进行优化

**Header压缩**

通过HPACK算法，在客户端和服务器同时维护一张头信息表，以后只发索引号不发字段，提高了速度，即**消除了重复的部分**

**二进制格式**
![](https://community-header-1306990603.cos.ap-guangzhou.myqcloud.com/20220111003454.png)

不再用纯文本形式的报文，而是采用二进制帧，**增加数据传输效率**

**服务端推送**

服务端不再被动响应，如：在发送页面 HTML 时主动推送其它 CSS/JS 资源，而不用等到浏览器解析到相应位置，发起请求再响应。

**多路复用**

HTTP/2 可以在**⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应。**

移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，⼤幅度**提⾼了连接的利⽤率**

**数据流**

数据包不是按顺序发送，每个请求或回应的所有数据包，称为⼀个**数据流（ Stream ）**。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数

客户端还可以**指定数据流的优先级。**优先级⾼的请求，服务器就先响应该请求。

**缺陷**

多个HTTP请求复用一个TCP连接，一旦丢包就会触发TCP重传机制，这样在⼀个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。
### HTTP3

针对HTTP2的缺陷，把下层协议改成了UDP，采用QUIC协议

**QUIC**
* QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到
影响。
* TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。
* HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3 的三次握⼿。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数

## HTTPS


* 信息加密:交互信息⽆法被窃取，通过**混合加密**实现
* 校验机制:⽆法篡改通信内容，篡改了就不能正常显示，通过**摘要算法**实现
* 身份证书:证明网站是真的，**将服务器公钥放入到数字证书**实现

### HTTP和HTTPS的区别

|        |     HTTP     |        HTTPS        |
| :----: | :----------: | :-----------------: |
| 端口号 |      80      |         443         |
|  传输  |   明文传输   | SSL/TLS使得传输加密 |
|  连接  | 三次握手即可 |   还要SSL/TLS握手   |
|  证书  |      无      |      向CA申请       |

### 混合加密

HTTPS 采⽤的是**对称加密**和**⾮对称加密**结合的「混合加密」⽅式：

* 在通信建⽴前采⽤**⾮对称加密**的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。
* 在通信过程中全部使⽤**对称加密**的「会话秘钥」的⽅式加密明⽂数据。

采⽤「混合加密」的⽅式的原因：

* **对称加密**只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。
* **⾮对称加密**使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度慢。

常见的对称加密算法：DES,3DES,AES(应用最广泛的对称加密算法)，GCM,CCM(分组模式的加密)

常见非对称加密算法：RSA(基于整数分解，用两个超大素数的乘积作为生成密钥材料)，ECC(基于椭圆曲线离散对数)
### 摘要算法

客户端在发送明⽂之前会通过摘要算法算出明⽂的「指纹」，发送的时候把「指纹 + 明⽂」⼀同加密成密⽂后，发送给服务器，服务器解密后，⽤相同的摘要算法算出发送过来的明⽂，通过⽐较客户端携带的「指纹」和当前算出的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。

常用的加密算法:MD5,SHA-2,HMAC

### TLS握手过程

不同的密钥交换算法会有区别，这里以RSA握手为例：
1. 第一次握手

客户端发送一个**Client Hello**消息，里面包含了客户端使用的TLS版本号，支持的密码套件，以及生成的**随机数**

2. 第二次握手

服务端收到客户端发来的消息后，返回**Server Hello**消息，里面有服务器确认的TLS版本号和一个**随机数**,并选择一个合适的密码套件（包含密钥交换算法+签名算法+对称加密算法+摘要算法）

然后发送**Server Certificate**，里面含有数字证书

>数字证书：⽤来认证公钥持有者的身份，以防⽌第三⽅进⾏冒充。⼀个数字证书通常包含了：公钥；持有者信息；证书认证机构（CA）的信息；CA 对这份⽂件的数字签名及使⽤的算法；证书有效期；还有⼀些其他额外信息

然后发送**Server Hello Done**，标志第二次握手结束

3. 第三次握手

客户端验证完证书后，生成一个新的随机数用服务器的RSA公钥加密后传送给服务端

>CA签发证书过程：将持有者的公钥，颁发者等信息打成一个包，然后Hash计算，并使用自己的私钥对该值加密，生成Certificate Signature，添加到文件证书上形成数字证书

>客户端对证书的验证：用相同的Hash算法获取证书的Hash值H1，并根据浏览器或操作系统中CA的公钥对证书的Certificate Signature进行解密得到H2，比较H1和H2

至此双方都共享了三个随机数，以此生成**会话密钥**对后续请求/响应的数据进行加解密。

⽣成完会话密钥后，然后客户端发⼀个「Change Cipher Spec」，告诉服务端开始使⽤加密⽅式发送消息

然后，客户端再发⼀个「Encrypted Handshake Message（Finishd）」消息，把之前所有发送的数据做个摘要，再⽤会话密钥（master secret）加密⼀下，让服务器做个验证，验证加密通信是否可⽤和之前握⼿信息是否有被中途篡改过。

4. 第四次握手

服务器也是同样的操作，发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双⽅都
验证加密和解密没问题，那么握⼿正式完成。

由于RSA不具备前向安全性质，ECDHE算法更被广泛使用，其原理先不做探讨
>前向安全：因为客户端传递随机数（⽤于⽣成对称加密密钥的条件之⼀）给服务端时使⽤的是公钥加密的，服务端收到到后，会⽤私钥解密得到随机数。所以⼀旦服务端的私钥泄漏了，过去被第三⽅截获的所有 TLS 通讯密⽂都会被破解。

ECDHE握手与RSA握手的不同:

* RSA 密钥协商算法「不⽀持」前向保密，ECDHE 密钥协商算法「⽀持」前向保密；
* 使⽤了 RSA 密钥协商算法，TLS 完成四次握⼿后，才能进⾏应⽤数据传输，⽽对于 ECDHE 算法，客户端可
以不⽤等服务端的最后⼀次 TLS 握⼿，就可以提前发出加密的 HTTP 数据，节省了⼀个消息的往返时间；
* 使⽤ ECDHE， 在 TLS 第 2 次握⼿中，会出现服务器端发出的「Server Key Exchange」消息，⽽ RSA 握⼿
过程没有该消息；

